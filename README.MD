# 🔹 Python Data Structures & Algorithm 🔹

## 📚 List
- **Description**: Ordered, mutable, allows duplicates.
- **Implementation**: `list`.
- **Time Complexity**: Access O(1), Insert O(n), Delete O(n).
- **Uses**: Storing collections of items (tasks, messages, numbers), retrieving by index.

---

## 📚 Array
- **Description**: Stores elements of the SAME TYPE in contiguous memory.
- **Implementation**: `array.array`.
- **Uses**: Large numerical data sets, mathematical operations, low memory usage.

---

## 📚 Linked List
- **Description**: Stores elements in nodes, with a pointer to the subsequent node.
- **Types**: singly, doubly, circular.
- **Uses**: Implementing queues, stacks, navigating forward or backward efficiently.

---

## 📚 Stack
- **Description**: LIFO (Last In, First Out) structure.
- **Implementation**: `list.append()` for push and `list.pop()` for pop.
- **Uses**: Text editors’ undo mechanisms, expression parsing, backtrack algorithms.

---

## 📚 Queue
- **Description**: FIFO (First In, First Out) structure.
- **Implementation**: `queue.Queue`.
- **Uses**: Task scheduling, CPU process queues, customer service lines.

---

## 📚 Deque
- **Description**: Double-ended queue.
- **Implementation**: `collections.deque`.
- **Uses**: Implementing both stack and queue efficiently, adding or removing from both ends.

---

## 📚 Tree
- **Description**: Hierarchical structure with parent-child relationships.
- **Types**: Binary tree, AVL, Red-Black tree, etc.
- **Uses**: File directory structures, expression trees, routing trees.

---

## 📚 Graphs
- **Description**: Consists of vertices (nodes) connected by edges.
- **Representation**: Adjacency list or adjacency matrix.
- **Uses**: Networks, social media relationships, transportation routes.

---

## 📚 Hashing (HashTable/HashMap)
- **Description**: Stores key-value pairs with fast lookup, insert, and delete operations.
- **Implementation**: `dict`.
- **Uses**: Caching, dictionaries, phone books, counting duplicates, or efficiently retrieving data by key.

---

## 🔹 Sorting Algorithm 🔹

### 1️⃣ Bubble Sort
- **Time Complexity**: O(n²)
- **Space Complexity**: O(1)
- **Description**: Repeating swaps until array is sorted.
- **Uses**: Small or nearly-sorted datasets.

---

### 2️⃣ Selection Sort
- **Time Complexity**: O(n²)
- **Space Complexity**: O(1)
- **Description**: Select minimum element and move forward.
- **Uses**: Small files, educational algorithm demonstrations.

---

### 3️⃣ Insertion Sort
- **Time Complexity**: O(n²)
- **Space Complexity**: O(1)
- **Description**: Insert elements into their correct place.
- **Uses**: Small or nearly-sorted arrays, real-time data.

---

### 4️⃣ Quick Sort
- **Time Complexity**: O(n log n) (average)
- **Space Complexity**: O(log n) (stack)
- **Description**: Divide-and-conquer algorithm with a pivot.
- **Uses**: Large arrays with well-distributed data.

---

### 5️⃣ Heap Sort
- **Time Complexity**: O(n log n)
- **Space Complexity**: O(1)
- **Description**: Sorts using a max-heap or a min-heap.
- **Uses**: Large data sets where space is limited.

---

### 6️⃣ Merge Sort
- **Time Complexity**: O(n log n)
- **Space Complexity**: O(n)
- **Description**: Divide-and-conquer algorithm by splitting and merging.
- **Uses**: Large data sets, external sorting, and stability.


